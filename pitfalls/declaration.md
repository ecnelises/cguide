###声明###
讲过 C 语言奇葩的字符串和乱七八糟的字符串声明，如果还没有晕掉的话，这次再来谈谈 C 语言里的其他各种各样的声明和关键字。

有一些关键字，如果不是做底层开发的话，可能永远都遇不到。不过，出于对语言全貌的了解，这里还是有必要介绍一下。另外，像``static``这种常用又容易混乱的关键字，更是能够体现 C 语言的基本功。

####静态####
顾名思义，static 就是“静态的”的意思。它可以用在变量或者函数返回值类型的前面。那么，如何体现这个静态呢？

我们知道，C 语言中组织代码模块的单位是函数。标准的 C 程序从 ``main()``函数启动，然后在这个函数里调用其他的函数或执行语句，完成某些任务，最后退出。即使再复杂庞大的 C 程序，也遵循这样的执行过程。一个函数执行另一个函数，一层一层完成函数调用的过程。

函数可以接受参数或者返回一个值。在每次调用函数的时候，函数调用的参数会按照一定的顺序被压入栈（函数参数压栈的具体方式跟系统也有关系，在 Windows 系统下可以手动声明函数的调用方式，比如``__cdecl``、``__stdcall``等），然后有返回值的返回返回值，没有返回值的就退出。

在函数调用完毕之前，会有一个所谓“清理堆栈”的过程。（“栈”在大陆计算机专业语言里跟“堆栈”是一个词，台湾叫做“堆叠”）函数会把调用时定义的局部变量占用的内存全部释放掉。而所谓**局部静态变量** (Local Static Variable) ，就是在函数调用结束时并不释放空间的变量。函数中定义的局部变量存储在 .data 段（还记得可执行文件的段吗？），而局部变量是存储在**调用栈** (Call Stack) 上的。

觉得太抽象？看看下面的代码：

	#include <stdio.h>
	
	void foo(void)
	{
		static int x = 0;
		printf("%d\n", x++);
	}
	
	int main(void)
	{
		foo();
		foo();
		foo();
	}

猜猜看输出结果是什么？是的，出乎意料地是``0 1 2``. 你也许会不解：不是每次函数调用的时候这里的``x``都会被赋值为 0 吗？为了说明这个问题，我们把代码中的``static int x = 0;``拆成两句，即``static int x = 0; x = 0;``，再看看结果。

咦，怎么变成了``0 0 0``呢？事实上，变量的赋值和初始化是不一样的，对于这里的静态变量而言，它的初始化只会在一开始执行一次（因为它占用的空间并未被释放）。而赋值作为一个语句，每次函数调用都会重复执行。如果对字符串一节还有印象，想一想``char * const str_dcl2;``这个指针定义。作为常指针，如果一开始没有被初始化，那之后不可能被再次赋值了。C++ 中可以以``int x(0);``这样的方式初始化（当然 x 既然都是变量了，那就不可能是一个函数），也许会让人区分得开一点。

我们可以更会玩一点，把``foo()``函数里所有的赋值和初始化都去掉：

	void foo(void)
	{
		static int x;
		printf("%d\n", x++);
	}

会发生什么呢？也许变量没有初始化，就会输出随机的数字吧。非也，不管执行多少次，结果都是雷打不动的``0 1 2``.

为什么？**因为全局变量和局部静态变量的生命周期是编译器可知的，它们被放在数据段里，所以基本的数据类型都会被默认初始化为 0.** 也就是说，再手动把它们初始化为 0 是没有必要的行为。

局部静态变量的存在有什么意义呢，仅仅是为了减少一次初始化吗？不。细细一想，函数中定义静态变量的后果就是，函数可以变得**不可重入** (Not Reentrant) 了。什么是可重入呢？也就是，如果我保持相同的输入（或者没有输入），函数一定会执行相同的动作，或者是返回相同的结果。而在上面的程序里面，每次调用输出的结果都是不同的。把结论推得更强一点就是，**这一次函数调用的结果，依赖于上一次函数调用的结果。**顺便说一句，在多线程程序当中，全局变量可以是不可重入的。这种不可重入的程序，在标准 C 库函数当中，有个十分典型的应用，就是伪随机数。

根据目前的计算机体系结构，计算机是没有办法产生真正的随机数的。（量子计算机遥遥无期）生成随机数的函数会通过某些算法（有兴趣的可以查一下，跟数论有关）生成一个数，然后保存到``static``变量里，下次又以这个数为起点开始算。当然，万物都有一个起点。这个随机数一开始也是通过一个数经过若干运算算出来的。一开始的这个数被称作**随机数种子** (Random Seed). 所以直接调用``rand()``函数会发现每次出来的随机数顺序都是一样的，因为随机数的种子是固定的。那怎么办呢？有一个很机智的办法，因为每一秒的时间都是不一样的，所以可以用当前的时间来作为随机数的种子。即在用到随机数的程序之前使用一次``srand(time(NULL));``就行了，不过记得包含``time.h``和``stdlib.h``头文件。

顺便说，在 C 语言中，最基本的时间表示方法是用一个整数（时间类型被定义为``time_t``，多数是由``int``定义的）来表示从 1970 年 1 月 1 日 00:00 到现在经过的秒数。所以有时候程序出问题了，时间变到了 1970 年不要大惊小怪。另外，在 32 位的计算机下，这个时间值到 2038 年 1 月 19 日就溢出了……

好了，说完了静态局部变量，又来聊聊静态全局变量。普通的全局变量和静态局部变量一样，被放在可执行文件的数据段里，自动初始化，生命周期贯穿整个程序运行的全过程。所以在设计 C 语言的时候，静态全局变量里的``static``有着截然不同的含义。这里的静态声明符的作用，是把该全局变量的范围限制在本文件里。也就是说，如果我在 implement.c 文件里定义了这样的静态全局变量：

	static int localglobal = 0;

我在这个源文件里的所有函数都可以访问这个全局变量。但是出了这个范围就不行了。也就是说这里的``static``标记可以起到隐藏内部实现的目的。如果没有这个标记，外部的文件是可以访问到这个变量的，并且如果产生了命名冲突，链接的时候会有问题。

同理，有``static``标记的函数也就是指作用域仅停留在本文件的函数。扯远一句，在 C++ 里，带有``static``的类的成员函数是静态的，不用定义对象就可以直接调用。
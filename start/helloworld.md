###Hello, world!###
传统上，学习一门语言的第一步就是所谓的“Hello, world!”啦，就是在屏幕上“打印”出这句话。所以也有人调侃说，程序员的小孩，刚生下来不是啼哭，而是大叫一声“Hello, world!”

	#include <stdio.h>
	
	int main(int argc, char *argv[])
	{
		printf("Hello, world!\n");
		return 0;
	}

你们肯定写过，没写过也没关系。我们在这里还是照着教科书上的惯例，一句一句说一下看看。

####include 是干嘛的####

这里的``#include <stdio.h>``是系统的一个“预处理”指令，也就是说，这行代码最终是不会经过编译变成程序的一部分的。那它要干什么呢？事实上，在 C 语言中，这些以井号开头的语句都是面向编译器的，它们在词法分析之前就会被处理。这里的``#include``，顾名思义，包含，包含一个名字叫``stdio.h``的文件，**将这个文件的内容完整地放到代码里**。那这个文件到底是干嘛的呢？如果我不写，会发生什么？

实践是检验真理的惟一标准。我们来实践一下。我把这一行去掉，其他不变，在笔者的 Clang 7 编译器上，出来的是这样的提示信息：

	a.c:4:5: warning: implicitly declaring library function 'printf' with type
      'int (const char *, ...)'
    printf("Hello, world!\n");
    ^
	a.c:4:5: note: include the header <stdio.h> or explicitly provide a
      declaration for 'printf'
	1 warning generated.

尽管如此，程序还是生成了，并且可以正常运行，结果也对。如果你有基本的英文阅读能力，那大概就能明白这个提示的意思。“警告：**隐式**地声明了一个库函数'printf'……”然后非常智能的 Clang 给出了修改建议，让我**包含**``stdio.h``文件。

什么？什么叫“声明”(Declaration)？什么又叫“函数”(Function)？什么是“库”(Library)？这些东西有什么用？不要急。你现在需要明白的只是，缺少了这里的这个``#include``命令，程序会缺点什么。大概……就像炒菜没放盐，吃着炸鸡你却不在……（打住！）

第二行是一个空行。说明了什么呢？删掉，留着，并没有什么区别。包括后面的东西，放在一起和分开，结果都是一样的，甚至编译器连警告都不会给。意思是，C 语言是一个**自由格式语言**(Free-format Language)，你可以不在意程序写成什么风格，用不用缩进，等等。在编译的时候，不必要的空格、换行、制表符（这是什么等会儿说，注意表字是不带女字旁的就行了）都会被忽略掉。那，有没有不是自由格式的语言呢？有，典型例子就是传说中的 Python 啦。

####何谓标准####

第三行感觉终于来到正题了是吧，你很熟悉的``main()``函数，但是好像长得有那么一点不一样。事实上，根据 C 语言的标准（什么，这玩意儿还有标准？），这两种定义方式都是合乎规则的：

	int main(void) { /*...*/ }
	int main(int argc, char *argv[]) { /*...*/ }

这里的``void``可以省略，``char *argv[]``也可以写成``char **argv``或者其它等价的什么形式。但是大概的意思是不变的，即前面的类型声明符必须是``int``而不是``void``或者``char``或者其它什么类型，然后括号里面的东西要么为空，要么带两个参数一个整数一个字符串数组。这里的 arg 指的是 argument，命令行参数。不懂没有关系，但是你一定要记住，写成这两种之一。**因为它是合法的。**

什么是合法的？如果我写得不合法，是不是警察叔叔就会敲寝室门来送温暖呢？不，不会的。你在南方的寒夜里写下一段代码，没有人，没有任何人会在乎它是什么样。也不会说因为你写了一个``void main()``你就学不好 C 语言了。不是的。这些看起来奇奇怪怪严苛无比的规定，产生于群雄争霸的上个世纪。面对 C 语言这块香饽饽，每个公司都想染指，都想私有，最好的方法就是利用自己的优势地位，将自己的方言变为事实标准，然后在此之上进一步拒绝对其它平台的兼容，最终让 C 语言走向封闭。最后每个公司都有每个公司的方言，每个平台都不一样，都有自己的 C 语言。那 C 就和伴它而生的 UNIX 的宗旨背道而驰了。

两千多年前的秦始皇都知道书同文车同轨，何况全球化的今日？人们意识到了这个问题，C 语言开始有了自己的标准，如果你的编译器想推广，那就必须先支持这一系列标准再说。类 UNIX 系统也有了自己的 POSIX 标准，不过那是后话了。说这么多，我的意思就是，其实遵不遵循所谓的标准，根本不是大事，甚至比起程序员之间津津乐道的编辑器之战都不值一提。但是，如果你相信世界大同，笃信开放、可移植，那就先从 C 标准开始吧。

当然，若干年前，年少无知的我随便点开了 Linux 内核源代码里的某个文件，然后发现它居然用的是``void main()``，我愤怒至极，贴到百度 C++ 吧里搞了个大新闻。结果后来才知道我 naive 了，人家是系统内核，返回值返回给谁呢……

####理解 printf####

接下来就是整个程序代码中可能惟一有用的一句了。``printf("Hello, world!\n");``，这行代码说明了太多东西。首先是代码最后要有分号``;``，这使得很多行代码可以写在一行里面，一行代码也可以拆成很多行，只要它以分号结束。这一约定影响了以后的很多程序设计语言，以至于苹果公司在 2014 年推出自己的新语言 Swift 的时候，还专门提出来说我们的这个语言一行完了可以不写分号。

外面一串字母，然后一个括号包一圈，这个叫一个**函数调用** (Function Call)，这里的函数跟数学上的函数并不完全等同。在有些程序语言里，除了函数，还有所谓**过程** (Procedure) 的概念。C 语言在这里并不作语法上的区分。总之，函数可以理解为一系列功能的实现。其实就算这行代码本身，也包含在 C 的主函数``main``里。括号里面的东西称作一个函数的**参数** (Parameter），用双引号标注起来的东西严格意义上的名字是**字符串字面值** (String Literal)。也许你并不想了解这些奇奇怪怪的概念，但是傻子也能猜出来，既然我们的功能是输出一句“Hello, world!”，而且 print 在英文里又有“打印”的意思，所以它的意思肯定就是这个啦。

好啦好啦，如果真的要深究 C 语言里的字符串，可能三天三夜都说不完（真的）。但是我们这里关注两点。一个是为什么这个函数名字要叫``printf``而不是``print``，另一个是这个结尾的``\n``到底又是什么意思。不过我猜你早就干过诸如输出矩阵一样的事情了，你知道它除了打印你喜欢谁谁谁以外还可以输出隔壁教室那个路都走不动的老教授多少岁了，自己还有多少钱。你也许还知道可以在打印小数（请叫我**浮点数**）的时候指定输出小数点后几位。那这个``f``意思就很明显了，即 format. ``printf``的意思就是按照一定的格式来**打印**数据。

等等，打印是什么意思，我又没有打印机，它……怎么打印给我？唔，说到这里又是历史问题了。开始的时候，给计算机写程序的人是没有当代这样的输入输出的（甚至有人说更早的时候程序真的是用电线来“编”的）。小时候看比尔盖茨的传记，他当年就真的是用纸带一个一个打孔输入进去的。屏幕的出现是稍后的事情了。没有屏幕，电脑就只有像打字机一样把结果用打印的方式输出来。所以在今天台式机的完整键盘上还能发现一些奇奇怪怪没有什么用的键，那就是打字机的历史遗留。

有了**终端** (Terminal) 之后，计算机程序终于可以在屏幕上输出了。但是请注意，那个时候的“屏幕”和今日的还有所不同。最初的屏幕由于技术限制甚至是深绿的，只能显示点阵字符。**图形用户界面** (Graphical User Interface, GUI) 的出现也是在显示技术发展之后的事情了。当代的电脑使用的东西叫作**虚拟终端** (Virtual Terminal) ，即把一个终端窗口当作是一台终端机，把电脑当做是终端机对应的服务器。你也许会对你的 Hello, world! 程序略感失望，因为它只是出现在一个黑漆漆的屏幕上（其实不一定是黑漆漆啦），甚至一闪而过。你以为程序是像 QQ，像网易云音乐（我真的没有在安利）一样的东西。但若你曾有心打开过 Windows 下的任务管理器，查看一下电脑里正在运行的**进程** (Process)，你会发现有大量的程序正在驻留在后台运行。你甚至根本看不见它们的踪影，连最朴素的黑窗都没有。这也叫程序。不管是打印出纸，还是在绿屏上显示一行字，抑或是在窗口上浮动着漂亮的图案，这些都是程序。**我们这段时间内学习的 C 语言代码，输出可以说根本就不重要，它只是为了让我们验证结果而已，而做一个窗口然后通过优美的设计展示在上面不是做不到，只是它与我们最初的目的相隔太远。**甚至为了验证某个计算的结果，我们完全可以不输出它，而是把它跟理想中的结果比较，如果相符，系统就“哔——”一声，完全可以。做图形界面的应用程序，也绝不是一件简单的事情。

>郑人买其椟而还其珠，此可谓善买椟矣，未可谓善鬻珠也。

回过头来说``\n``，如果去掉它，我们看看输入结果，相当于少了一个回车。如果你理解得不深刻，那就在它代码的下一行再插入一个``printf``语句，看看结果如何。为什么要用``\n``来表示回车呢。很简单啊，你在代码里不输入``\n``，写成这样试试：

	printf("Hello, world!
	");

然并卵，甚至还报错了：

	a.c:5:12: warning: missing terminating '"' character [-Winvalid-pp-token]
    printf("Hello, world!
           ^
	a.c:5:12: error: expected expression
	a.c:6:13: warning: missing terminating '"' character [-Winvalid-pp-token]
            ");
            ^
	a.c:8:2: error: expected '}'
	}
	 ^
	a.c:4:1: note: to match this '{'
	{
	^

所以还是老老实实用``\n``吧。

像``\n``这样的字符，虽然输入的时候是两个字，但是实际上电脑会把它当作一个字，即换行符。这种字符在 C 语言里称之为**转义字符** (Escape Character) ，转义字符有很多，但是你现在能用到的大概除了``\n``就是``\t``（上面提到过的制表符）了吧。

说说制表符。在图形界面的时代，这个东西貌似已经没多大用了。键盘上的 Tab 键甚至在很多情况下都是用来切换输入焦点的。顾名思义，制表符，制表，就是用来对齐的。如果遇到这种情况：

	15		5		1
	3252	142		7

其实我根本不需要狂按空格来对齐（字体非等宽的时候还对不齐），在我编辑的时候，我把这个 5 换成 55 甚至是 555 都不会影响到右边 1 的位置。因为我数与数中间隔的是一个或多个 Tab ，它会自动帮我对齐。系统会设定一个 Tab 最大对应的字符数量，有的是 4 ，有的是 8. 意思就是说，在最大为 4 的情况下，如果我想表示 6 个空格的间隔，我得输入两个 Tab 才行。对制表符更具体的直观感受，大家可以在系统自带的记事本里实验一下。

然后讲讲另一个有故事的转义字符``\r``，意思是 return（回车），它跟前面的``\n``（换行）不太一样。这也是有历史沿革的事。

在打字机的时代，如果打完一行需要换行的话，要做两件事情。一件是把纸往上移一行，一件是让打字机重新从新行左边的开头开始打印。这对应的是两个键。同样它沿袭到了计算机时代，这个``\r``代表的是回到左边（所以叫 return 嘛），而``\n``是换新一行。你可以试试把输出函数里的``\n``换成``\r``，你会发现什么输出也没有了。所以……明白了吧？

在换行到底用``\r\n``还是``\n``的问题上，不同的操作系统出现了分歧。Windows 坚持两个都用（在 VB 里这两个字符合在一起叫 CRLF ），而 UNIX 系（有空说说 UNIX 的历史，也是很有意思的事）使用``\n``代表换行符。在基本的 C 语言输出里，这个是没有问题的，因为``printf``函数的内部实现会自己加上这个``\r``，可倘若你和你用 OS X 或者 Linux 的朋友一起分享一个文件，那就会产生问题了。比方说，用 Vim 打开，会是这样的……

	int main(void)^M
	{^M
		return 0;^M
	}^M

你得手动消除。不过现代的编辑器都有自动识别的功能。而 Windows 平台上的一些系统函数，比如``DrawText()``，参数就需要手动加上``\r``了。

顺便说一句，这些转义字符都是在 _ASCII_ 码表里能够找到的。

####返回值####
好啦，前面说到了回车那个 return ，这里又有一个 return ，不过意思变了。在 C 语言里，函数前面有一个类型标识符，这表示了这个函数会**返回**一个什么样的结果。如果是``void``，那就是没有返回值，说明这个函数仅仅是做一些操作，比如输出信息，修改文件，我们无需获取它的结果。举个好理解的例子，函数``sin(x)``，这个函数的返回值为``double``类型（如果你不是很清楚的话，先理解成小数吧）。那么，这个函数返回的值，就是这个正弦函数的计算结果。从这个意义上说，计算机编程里的函数和数学概念中的函数有相似的地方。

那``main()``函数返回什么呢？有什么意义呢？这里的``return 0;``据某些书上写，省略掉也是符合标准的。但是我没有去求证。这里的这个 0 是返回给操作系统，或者说是你运行这个程序使用的终端的。根据 C 和 UNIX 的规定，0 表示运行成功，没有出错。你也许会说，那就算程序出错了，它不也成功退出了吗，有用咩？

当然有用了。特别是如果你用过 Linux 或者其它类 UNIX 系统的 Shell 的话。在笔者电脑上安装的 zsh 上，如果把这个程序的返回值改为 -1，然后编译运行。结束以后的这个命令提示符会从绿色变为红色，就像编译一个 C 程序的时候出错中断了一样。它的意思是上一个程序**并没有成功地得到执行，从而后面的工作（如果有的话）无法继续进行**。很多时候，电脑里的程序是按一定的顺序运行的。比如说，你要先洗衣服，再晾起来，如果你没有洗好，你就不应该把它挂起来。那么我们假设洗衣服和晾衣服是两个程序来做的，洗衣服的程序如果执行失败，它返回一个 -1 或者什么值（完全可以规定每个非 0 值代表什么类型的错误），然后传递给系统或者 Shell （这个词的意思以后我也会说的），接下来晾衣服的程序启动，发现洗衣服的程序返回的值不是 0，那它会自动停止。识得唔识得噶？

如果你用过 UNIX 上的**管道** (Pipeline) 或者写过 Shell 脚本哪怕是 Windows 上的批处理的话，你的了解应该会更深一层。所以说啊，合格的写 C 的程序员必须对 Linux 有所了解。当然，你可能没有必要在自己的电脑上装一个，因为……

####漂亮的花括号####
第 4 行的花括号忘讲了，那就说说结尾的花括号呗。

在 C 语言中，函数体（就是函数里面的部分），必须用花括号括起来，不管有多少行。

明白``if``和``while``等语句的同学可能会偷懒不写花括号。但是**永远不要高估人类的谨慎度**。比如之前有位朋友问了我这段**选择排序** (Selection Sort) 的代码为什么执行不对：

	/* 前面省略 */
	for(i=0;i<n-1;i++)	{		for(j=i+1;j<n;j++)		{ 			if(array[j]<array[i])			t=array[i];array[i]=array[j];array[j]=t;
		} 	}
	/* 后面省略 */

说实话，我看了半天还真没看出来它到底出了什么问题。你呢？

实际上，千万不要以为只有新手才会犯这样的错误。许多重大甚至人命关天的程序也不能保证每个``if``语句都不会这样。所以说， 为了自己和他人的安全，请加上花括号吧。

你看，这个短短 7 行的 Hello, world! （标点后面空一格是英文习惯，以后写英语论文什么的都要注意），还有一个空行，我们可以说这么多。所以说，**你写的每一行代码，就像你做的菜，写的文章一样，都是你的作品**。我希望每一个人都能把自己从 Hello, world! 以来写的所有代码都保留在电脑上。话说，李开复老师曾经说过，一个合格的计算机系大学生，本科期间代码应该超过 10 万行，你猜 10 万行是多少？